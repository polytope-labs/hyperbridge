---
title: IndexerClient
description: Learn how to use IndexerClient to query the Hyperbridge indexer and monitor cross-chain request statuses.
---

# IndexerClient

The `IndexerClient` provides a simple interface for querying the Hyperbridge indexer and monitoring cross-chain request statuses in real-time. It handles the complexity of tracking requests across multiple chains and provides streaming APIs for real-time updates.

## When to Use IndexerClient

Use `IndexerClient` when you need to:

- **Track request progress** - Monitor the lifecycle of cross-chain requests from source to destination
- **Handle timeouts** - Detect and process requests that exceed their timeout period
- **Query request status** - Get the current state of a request without streaming
- **Build user interfaces** - Display real-time status updates to users
- **Implement notifications** - Trigger actions when requests reach specific states

## Quick Start

Here's a minimal example to get started:

```typescript
import { IndexerClient, createQueryClient, EvmChain, SubstrateChain } from "@hyperbridge/sdk"

// Create query client
const queryClient = createQueryClient({
  url: "https://hyperbridge-indexer-url"
})

// Create chain instances
const sourceChain = new EvmChain({
  chainId: 97,
  rpcUrl: "https://bsc-testnet-rpc.com",
  host: "0xSourceHostAddress",
  consensusStateId: "BSC0"
})

const destChain = new EvmChain({
  chainId: 10200,
  rpcUrl: "https://rpc.chiadochain.net",
  host: "0xDestHostAddress",
  consensusStateId: "GNO0"
})

const hyperbridge = new SubstrateChain({
  stateMachineId: "KUSAMA-4009",
  wsUrl: "wss://gargantua.polytope.technology",
  hasher: "Keccak",
  consensusStateId: "PAS0"
})

await hyperbridge.connect()

// Initialize IndexerClient
const indexer = new IndexerClient({
  queryClient,
  pollInterval: 1_000, // Poll every 1 second
  source: sourceChain,
  dest: destChain,
  hyperbridge
})
```

For detailed setup instructions, see [Getting Started](/developers/sdk/getting-started#indexerclient-configuration).

## Tracking Request Status

### Streaming Status Updates

The most common use case is streaming status updates for a POST request:

```typescript
async function trackRequest(requestHash: string) {
  try {
    for await (const status of indexer.postRequestStatusStream(requestHash)) {
      console.log(`Status: ${status.status}`)
      console.log(`Block: ${status.metadata.blockNumber}`)
      console.log(`TX Hash: ${status.metadata.transactionHash}`)
      
      // Handle different status states
      switch (status.status) {
        case "SOURCE":
          console.log("✓ Request dispatched from source chain")
          break
        case "SOURCE_FINALIZED":
          console.log("✓ Request finalized on source chain")
          break
        case "HYPERBRIDGE_DELIVERED":
          console.log("✓ Request delivered to Hyperbridge")
          break
        case "HYPERBRIDGE_FINALIZED":
          console.log("✓ Request finalized on Hyperbridge")
          break
        case "DESTINATION":
          console.log("✓ Request executed on destination chain!")
          return // Terminal state - success!
        case "PENDING_TIMEOUT":
          console.log("⚠ Request timed out")
          return // Terminal state - needs timeout handling
      }
    }
  } catch (error) {
    console.error("Error tracking request:", error)
  }
}
```

### Querying Current Status

For one-off status checks without streaming:

```typescript
async function checkStatus(commitmentHash: string) {
  const request = await indexer.queryRequestWithStatus(commitmentHash)
  
  if (!request) {
    console.log("Request not found")
    return
  }
  
  console.log("Current Status:", request.status)
  console.log("Latest Block:", request.data.sourceChainBlock)
}
```

## Handling Timeouts

When a request exceeds its timeout period, you'll receive a `PENDING_TIMEOUT` status. Use the timeout stream to track timeout processing:

```typescript
async function trackRequestWithTimeout(requestHash: string) {
  // First, track the normal request lifecycle
  for await (const status of indexer.postRequestStatusStream(requestHash)) {
    console.log(`Status: ${status.status}`)
    
    if (status.status === "DESTINATION") {
      console.log("Request completed successfully!")
      return
    }
    
    if (status.status === "PENDING_TIMEOUT") {
      console.log("Request timed out, tracking timeout process...")
      break
    }
  }
  
  // Now track the timeout processing
  for await (const timeoutStatus of indexer.postRequestTimeoutStream(requestHash)) {
    console.log(`Timeout Status: ${timeoutStatus.status}`)
    
    switch (timeoutStatus.status) {
      case "DESTINATION_FINALIZED_TIMEOUT":
        console.log("Timeout finalized on destination")
        break
      case "HYPERBRIDGE_TIMED_OUT":
        console.log("Timeout message delivered to Hyperbridge")
        break
      case "HYPERBRIDGE_FINALIZED_TIMEOUT":
        console.log("Timeout finalized on Hyperbridge")
        break
      case "TIMED_OUT":
        console.log("Timeout process complete - funds returned to source")
        return // Terminal state
    }
  }
}
```

## Tracking GET Requests

GET requests work similarly to POST requests:

```typescript
async function trackGetRequest(requestHash: string) {
  for await (const status of indexer.getRequestStatusStream(requestHash)) {
    console.log(`GET Request Status: ${status.status}`)
    
    if (status.status === "DESTINATION" || status.status === "PENDING_TIMEOUT") {
      break
    }
  }
}
```

## Configuration Best Practices

### Poll Interval Selection

Choose your poll interval based on your use case:

| Interval | Use Case | Tradeoffs |
|----------|----------|-----------|
| `1_000` (1s) | Real-time UI updates, critical applications | Higher API load, faster response |
| `5_000` (5s) | Standard monitoring, dashboards | Balanced load and responsiveness |
| `10_000` (10s) | Background tasks, non-critical tracking | Lower API load, slower updates |
| `30_000` (30s) | Periodic checks, archival | Minimal API load, delayed updates |

```typescript
// For real-time user-facing applications
const indexer = new IndexerClient({
  queryClient,
  pollInterval: 1_000, // 1 second
  // ...
})

// For background monitoring
const indexer = new IndexerClient({
  queryClient,
  pollInterval: 10_000, // 10 seconds
  // ...
})
```

### Error Handling

Always implement error handling for stream operations:

```typescript
async function robustTracking(requestHash: string) {
  const maxRetries = 3
  let retries = 0
  
  while (retries < maxRetries) {
    try {
      for await (const status of indexer.postRequestStatusStream(requestHash)) {
        console.log(`Status: ${status.status}`)
        
        if (status.status === "DESTINATION" || status.status === "PENDING_TIMEOUT") {
          return status
        }
      }
    } catch (error) {
      retries++
      console.error(`Attempt ${retries} failed:`, error)
      
      if (retries < maxRetries) {
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 5000))
      } else {
        throw new Error("Max retries exceeded")
      }
    }
  }
}
```

## Hash Flexibility

The IndexerClient accepts multiple hash types for convenience:

```typescript
// Any of these will work:
const requestHash = "0xabc..."  // Request commitment hash
const txHash = "0xdef..."       // Source chain transaction hash
const hbTxHash = "0x123..."     // Hyperbridge transaction hash
const destTxHash = "0x456..."   // Destination chain transaction hash

// The indexer automatically resolves them
for await (const status of indexer.postRequestStatusStream(requestHash)) {
  // Works with any hash type
}
```

## Building a Status Dashboard

Here's a practical example of building a status dashboard component:

```typescript
interface RequestStatus {
  hash: string
  currentStatus: string
  blockNumber: number
  timestamp?: number
  isComplete: boolean
}

class RequestDashboard {
  private indexer: IndexerClient
  private requests: Map<string, RequestStatus> = new Map()
  
  constructor(indexer: IndexerClient) {
    this.indexer = indexer
  }
  
  async trackRequest(hash: string): Promise<void> {
    this.requests.set(hash, {
      hash,
      currentStatus: "PENDING",
      blockNumber: 0,
      isComplete: false
    })
    
    for await (const status of this.indexer.postRequestStatusStream(hash)) {
      this.requests.set(hash, {
        hash,
        currentStatus: status.status,
        blockNumber: status.metadata.blockNumber,
        timestamp: status.metadata.timestamp,
        isComplete: status.status === "DESTINATION" || status.status === "PENDING_TIMEOUT"
      })
      
      // Notify UI to update
      this.onStatusUpdate(hash)
      
      if (status.status === "DESTINATION" || status.status === "PENDING_TIMEOUT") {
        break
      }
    }
  }
  
  private onStatusUpdate(hash: string): void {
    // Emit event or trigger UI update
    console.log("Request updated:", this.requests.get(hash))
  }
  
  getStatus(hash: string): RequestStatus | undefined {
    return this.requests.get(hash)
  }
  
  getAllStatuses(): RequestStatus[] {
    return Array.from(this.requests.values())
  }
}

// Usage
const dashboard = new RequestDashboard(indexer)
await dashboard.trackRequest("0xabc...")
```

## API Reference

For complete API documentation including all methods, parameters, and return types, see:

- [IndexerClient API Reference](/developers/sdk/api/indexer-client) - Complete API documentation

## Related

- [Getting Started](/developers/sdk/getting-started) - SDK setup and initialization
- [Tracking Requests](/developers/sdk/tracking/requests) - Detailed request tracking guide
- [IChain Interface](/developers/sdk/ichain-interface) - Chain instance documentation