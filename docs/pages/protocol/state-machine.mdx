# State Machine Client

Now that we have a way to verify the consensus proofs of a blockchain in a fully byzantine fault tolerant manner. We might like to read the state of the blockchain. This allows us to process any outgoing requests addressed to us stored in the state trie of the blockchain. In order to read the state of the blockchain weâ€™ll make use of state proofs. Different blockchains may different kinds of state tries. Merkle-patricia, IAVL, verkle tries, binary merkle trees, whatever the case may be, it is also the responsibility of the consensus client to provide the ISMP framework with an implementation of the `StateMachineClient`.

The state machine client is an abstraction over the state proof scheme of a given state machine. By decoupling the `ConsensusClient` from the `StateMachineClient` which are typically combined to form a *light client*, the ISMP framework allows a consensus client to support multiple state machines, each potentially using different state proof schemes. This abstraction makes ISMP future-proof, enabling deployment on both monolithic and modular blockchain architectures, including Polkadot, Ethereum, and others.


<figure>
  <img src="/full-node.jpeg" alt="A Full Node" />
</figure>

```rust
/// Convenience enum 
pub enum RequestResponse {
    /// A batch of requests
    Request(Vec<Request>),
    /// A batch of responses
    Response(Vec<Response>),
}

/// Proof holds the relevant proof data for the context in which it's used.
pub struct Proof {
    /// The state machine identifier
    pub id: StateMachineId,
    /// the corresponding block height
    pub height: u64,
    /// Serialized proof
    pub proof: Vec<u8>,
}

/// A state machine client. An abstraction for the mechanism of state proof verification for state
/// machines
pub trait StateMachineClient {
    /// Verify the overlay membership proof of a batch of requests/responses.
    fn verify_membership(
        &self,
        host: &dyn IsmpHost,
        item: RequestResponse,
        root: StateCommitment,
        proof: &Proof,
    ) -> Result<(), Error>;

    /// Transform the requests/responses into their equivalent key in the state trie.
    fn state_trie_key(&self, request: RequestResponse) -> Vec<Vec<u8>>;

    /// Verify the state of proof of some arbitrary data. Should return the verified data
    fn verify_state_proof(
        &self,
        host: &dyn IsmpHost,
        keys: Vec<Vec<u8>>,
        root: StateCommitment,
        proof: &Proof,
    ) -> Result<BTreeMap<Vec<u8>, Option<Vec<u8>>>, Error>;
}
```

## `verify_membership`

## `state_trie_key`

## `verify_state_proof`
