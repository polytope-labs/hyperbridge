# Intent Gateway SDK Guide

This guide explains how to use the Hyperbridge Intent Gateway SDK to place cross-chain orders with profitable fees and handle order cancellations using cryptographic proofs.

## Overview

The Intent Gateway SDK provides a TypeScript interface for interacting with the Intent Gateway smart contracts. It handles:

- **Fee Estimation**: Calculate profitable fees that incentivize fillers to process orders
- **Protocol Discovery**: Find the best Uniswap protocol (V2/V3/V4) for token swaps
- **Order Management**: Place, monitor, and cancel cross-chain orders
- **Proof Handling**: Generate and submit cryptographic proofs for order cancellation

The SDK abstracts away complex calculations like:

- Gas estimation across chains
- Fee token conversions
- Protocol fee calculations
- Relayer fee determination
- Cancellation proof handling and submission

## Getting Started

### Installation

```bash
npm install @hyperbridge/sdk
```

### Basic Setup

```typescript
import { EvmChain } from "@hyperbridge/sdk/chain";
import { IntentGateway } from "@hyperbridge/sdk/protocols/intents";
import { ChainConfigService } from "@hyperbridge/sdk/configs/ChainConfigService";

// Initialize chain configuration service
const chainConfigService = new ChainConfigService();

// Set up source chain (e.g., BSC)
const bscChain = new EvmChain({
  chainId: 56,
  host: chainConfigService.getHostAddress("EVM-56"),
  rpcUrl: "https://bsc-dataseed.binance.org",
});

// Set up destination chain (e.g., Ethereum)
const ethChain = new EvmChain({
  chainId: 1,
  host: chainConfigService.getHostAddress("EVM-1"),
  rpcUrl: "https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY",
});

// Create Intent Gateway instance (first param is source, second is destination)
const intentGateway = new IntentGateway(bscChain, ethChain);
```

## Estimating Profitable Fees

The most critical feature of the SDK is **estimating the correct fees** to make orders profitable for fillers. If fees are too low, no filler will process your order.

### Understanding Fee Components

An order's total fee consists of:

1. **Fill Gas Cost**: Gas required to execute `fillOrder()` on destination chain
2. **Protocol Fee**: ISMP messaging fees for cross-chain communication
3. **Relayer Fee**: Minimum $0.05 + execution costs for message delivery
4. **Buffer**: Safety margin (2.5-30% depending on chain volatility)

The SDK's `estimateFillOrder()` method calculates all these components automatically.

### Basic Fee Estimation

```typescript
import { bytes20ToBytes32 } from "@hyperbridge/sdk/utils";
import { Order } from "@hyperbridge/sdk/types";

// Create your order (note: sourceChain and destChain are hex-encoded)
// Note: One input token is supported in IntentGatewayV1, but multiple output tokens maybe supported through calldata execution
let order = {
  user: bytes20ToBytes32("0xYourAddress"),
  sourceChain: await bscIsmpHost.read.host(), // Hex-encoded "EVM-56"
  destChain: await ethIsmpHost.read.host(), // Hex-encoded "EVM-1"
  deadline: 20000000n, // Block number on Ethereum
  nonce: 0n,
  fees: 0n, // We'll calculate this
  outputs: [
    {
      token: bytes20ToBytes32("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"), // USDC on Ethereum
      amount: 1000_000_000n, // 1000 USDC (6 decimals)
      beneficiary: bytes20ToBytes32("0xRecipientAddress"),
    },
  ],
  inputs: [
    {
      token: bytes20ToBytes32("0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d"), // USDC on BSC
      amount: 1000_000_000_000_000_000_000n, // 1000 USDC (18 decimals on BSC)
    },
  ],
  callData: "0x",
};

// Estimate fees
const {
  order, // Same order object with fee included
  feeTokenAmount, // order.fees
  nativeTokenAmount, // order.fees converted to native token
  postRequestCalldata, // calldata for the ISMP post request
} = await intentGateway.estimateFillOrder(order);

console.log(`Fee in fee token: ${feeTokenAmount}`); // e.g., 2_800_000_000_000_000_000 (2.8 DAI)
console.log(`Fee in native token: ${nativeTokenAmount}`); // e.g., equivalent ETH amount
```

### How Fee Estimation Works

The `estimateFillOrder()` method performs these steps:

1. **Constructs Post Request**: Creates the ISMP post request for settlement
2. **Estimates Fill Gas**: Simulates `fillOrder()` execution with state overrides for allowances & balances
3. **Calculates Protocol Fee**: Queries ISMP host for message costs
4. **Determines Relayer Fee**: Adds minimum $0.05 + execution costs
5. **Converts to Fee Token**: Converts all costs to source chain's fee token
6. **Adds Safety Buffer**: Adds 2.5-30% buffer based on chain volatility

## Placing Orders

Once you have the correct fees, you can place orders directly on the Intent Gateway contract.

### Complete Order Placement Flow

```typescript
import { createWalletClient, http, parseUnits } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import IntentGatewayABI from "@hyperbridge/sdk/abis/IntentGateway";

// 1. Set up wallet
const account = privateKeyToAccount("0xYourPrivateKey");
const walletClient = createWalletClient({
  account,
  chain: bsc,
  transport: http("https://bsc-dataseed.binance.org"),
});

// 2. Get order with estimated fees
const order = {
  user: bytes20ToBytes32(account.address),
  sourceChain: await bscIsmpHost.read.host(),
  destChain: await ethIsmpHost.read.host(),
  deadline: 20000000n,
  nonce: 0n, // Will be set by contract
  fees: 20000000n, // From estimation
  outputs: [
    {
      token: bytes20ToBytes32(ethUsdcAddress),
      amount: parseUnits("1000", 6), // 1000 USDC
      beneficiary: bytes20ToBytes32(recipientAddress),
    },
  ],
  inputs: [
    {
      token: bytes20ToBytes32(bscUsdcAddress),
      amount: parseUnits("1000", 18), // 1000 USDC (18 decimals on BSC)
    },
  ],
  callData: "0x",
};

// 3. Approve input tokens
const ERC20_ABI = [
  {
    name: "approve",
    type: "function",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ name: "", type: "bool" }],
  },
];

const inputToken = getContract({
  address: bscUsdcAddress,
  abi: ERC20_ABI,
  client: walletClient,
});

await inputToken.write.approve([intentGatewayAddress, order.inputs[0].amount]);

// 4. Submit order with native token payment (no fee token approval needed)
const hash = await walletClient.writeContract({
  address: intentGatewayAddress,
  abi: IntentGatewayABI.ABI,
  functionName: "placeOrder",
  args: [
    order,
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  ], // graffiti
  value: nativeTokenAmount, // Pay fees with native BNB
});

console.log(`Order placed: ${hash}`);
```

### Paying Fees with Fee Token (Alternative)

Alternatively, you can pay fees directly with the fee token instead of native tokens:

```typescript
// Approve the fee token (e.g., DAI on BSC)
const feeToken = getContract({
  address: feeTokenAddress,
  abi: ERC20_ABI,
  client: walletClient,
});

await feeToken.write.approve([intentGatewayAddress, order.fees]);

// Submit order without value parameter
const hash = await walletClient.writeContract({
  address: intentGatewayAddress,
  abi: IntentGatewayABI.ABI,
  functionName: "placeOrder",
  args: [
    order,
    "0x0000000000000000000000000000000000000000000000000000000000000000",
  ],
  // No value parameter - fees paid with fee token
});
```

**When to use each payment method:**

- **Native Token (BNB/ETH)**: Simpler UX, no need to hold fee tokens, recommended for most users
- **Fee Token (DAI/USDC)**: More predictable costs, better for integrators and fillers

## Checking Order Status

### Check if Order is Filled

```typescript
const isFilled = await intentGateway.isOrderFilled(order);

if (isFilled) {
  console.log("Order has been filled by a filler");
} else {
  console.log("Order is still pending");
}
```

This method:

1. Calculates the order's commitment hash
2. Queries the destination chain's Intent Gateway storage
3. Returns `true` if the order was filled, `false` otherwise

## Canceling Orders

Order cancellation proves on-chain that an order was not filled before its deadline. The SDK automates fetching proofs, tracking finality, submitting the Hyperbridge message, and resuming from interruptions.

### When to Cancel

You can cancel an order when:

- The deadline has passed (order expired)
- The order has not been filled, which can be due to calldata execution reverting.
- You want to recover escrowed tokens and fees

### The Cancellation Process

The SDK orchestrates the [ISMP GET request](/protocol/ismp/requests) flow. Your responsibilities are:

1. Start the cancellation generator.
2. Wait for `DESTINATION_FINALIZED` and read the finalized height.
3. Submit the `cancelOrder` transaction on source chain with `{ relayerFee, height }`.
4. Provide the resulting transaction hash back to the generator when it yields `AWAITING_GET_REQUEST`.
5. Iterate until `HYPERBRIDGE_FINALIZED`.

### Basic Cancellation

```typescript
import { IndexerClient } from "@hyperbridge/sdk/client";
import { createQueryClient } from "@hyperbridge/sdk/query-client";
import { EvmChain, SubstrateChain } from "@hyperbridge/sdk/chain";

// 1. Create/reuse the indexer client
const queryClient = createQueryClient({
  url: "https://indexer.hyperbridge.network",
});
const sourceChain = new EvmChain({
  chainId: 56,
  host: bscHostAddress,
  rpcUrl: "https://bsc-dataseed.binance.org",
});
const destChain = new EvmChain({
  chainId: 1,
  host: ethHostAddress,
  rpcUrl: "https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY",
});
const hyperbridgeChain = new SubstrateChain({
  wsUrl: "wss://hyperbridge.polkadot.io",
  stateMachineId: "KUSAMA-4009",
  consensusStateId: "PAS0",
  hasher: "Keccak",
});
await hyperbridgeChain.connect();

const indexerClient = new IndexerClient({
  source: sourceChain,
  dest: destChain,
  hyperbridge: hyperbridgeChain,
  queryClient,
  pollInterval: 1_000,
});

// 2. Start cancellation (generator)
const cancelGen = intentGateway.cancelOrder(order, indexerClient);

// 3. Wait for destination finalization
let step = await cancelGen.next();
while (!step.done && step.value?.status !== "DESTINATION_FINALIZED") {
  step = await cancelGen.next();
}

const finalizedHeight = step.value.data.proof.height;
```

### Submit cancel transaction and continue

```typescript
// 4. Get native amount required to dispatch GET, then submit cancel on source
const nativeRequired = await intentGateway.quoteCancelNative(order);

const cancelOptions = {
  relayerFee: 0n,
  height: finalizedHeight,
};

// Resolve the IntentGateway address on the source chain
const intentGatewayAddress = sourceChain.configService.getIntentGatewayAddress(
  sourceChain.config.stateMachineId
);

const hash = await walletClient.writeContract({
  address: intentGatewayAddress,
  abi: IntentGatewayABI.ABI,
  functionName: "cancelOrder",
  args: [order, cancelOptions],
  value: nativeRequired,
});

// 5. Provide the transaction hash back to the generator
let result = await cancelGen.next(hash);
```

### Completing the Cancellation

```typescript
// 6. Monitor until Hyperbridge finalizes
while (!result.done) {
  if (result.value?.status === "HYPERBRIDGE_FINALIZED") {
    console.log("Cancellation complete!");
    console.log(`Refund tx: ${result.value.data.metadata.transactionHash}`);
    break;
  }
  result = await cancelGen.next();
}
```

### Automatic resume on interruptions

The SDK persists intermediate data (destination proof, GET request, source proof). If your process restarts, call `cancelOrder(order, indexerClient)` again; it will resume automatically.

## Complete Examples

### Example 1: BSC to Ethereum USDC Transfer

```typescript
import { EvmChain } from "@hyperbridge/sdk/chain";
import { IntentGateway } from "@hyperbridge/sdk/protocols/intents";
import { ChainConfigService } from "@hyperbridge/sdk/configs/ChainConfigService";
import {
  orderCommitment,
  hexToString,
  bytes20ToBytes32,
} from "@hyperbridge/sdk/utils";
import {
  parseUnits,
  formatUnits,
  formatEther,
  createWalletClient,
  createPublicClient,
  http,
  getContract,
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { bsc, mainnet } from "viem/chains";
import IntentGatewayABI from "@hyperbridge/sdk/abis/IntentGateway";
import EVM_HOST from "@hyperbridge/sdk/abis/evmHost";
import type { HexString } from "@hyperbridge/sdk/types";

async function transferUSDCFromBSCToEthereum() {
  // 1. Setup
  const chainConfig = new ChainConfigService();
  const account = privateKeyToAccount(process.env.PRIVATE_KEY);

  const bscChain = new EvmChain({
    chainId: 56,
    host: chainConfig.getHostAddress("EVM-56"),
    rpcUrl: process.env.BSC_RPC,
  });

  const ethChain = new EvmChain({
    chainId: 1,
    host: chainConfig.getHostAddress("EVM-1"),
    rpcUrl: process.env.ETH_RPC,
  });

  const intentGateway = new IntentGateway(bscChain, ethChain); // source, dest

  // 2. Create order
  const bscUSDC = chainConfig.getUsdcAsset("EVM-56");
  const ethUSDC = chainConfig.getUsdcAsset("EVM-1");

  // Get ISMP hosts to read chain identifiers
  const bscPublicClient = createPublicClient({
    chain: bsc,
    transport: http(process.env.BSC_RPC),
  });
  const ethPublicClient = createPublicClient({
    chain: mainnet,
    transport: http(process.env.ETH_RPC),
  });
  const bscIsmpHost = getContract({
    address: chainConfig.getHostAddress("EVM-56"),
    abi: EVM_HOST.ABI,
    client: bscPublicClient,
  });
  const ethIsmpHost = getContract({
    address: chainConfig.getHostAddress("EVM-1"),
    abi: EVM_HOST.ABI,
    client: ethPublicClient,
  });

  let order = {
    user: bytes20ToBytes32(account.address),
    sourceChain: await bscIsmpHost.read.host(), // Hex-encoded "EVM-56"
    destChain: await ethIsmpHost.read.host(), // Hex-encoded "EVM-1"
    deadline: 20000000n, // Ethereum block number
    nonce: 0n,
    fees: 0n, // Will calculate
    outputs: [
      {
        token: bytes20ToBytes32(ethUSDC),
        amount: parseUnits("1000", 6),
        beneficiary: bytes20ToBytes32(account.address),
      },
    ],
    inputs: [
      {
        token: bytes20ToBytes32(bscUSDC),
        amount: parseUnits("1000", 18),
      },
    ],
    callData: "0x",
  };

  // 3. Estimate fees
  const { order, nativeTokenAmount } =
    await intentGateway.estimateFillOrder(order);

  // 4. Approve and place order
  const walletClient = createWalletClient({
    account,
    chain: bsc,
    transport: http(process.env.BSC_RPC),
  });

  // Approve input token
  await walletClient.writeContract({
    address: bscUSDC,
    abi: ERC20_ABI,
    functionName: "approve",
    args: [
      chainConfig.getIntentGatewayAddress("EVM-56"),
      parseUnits("1000", 18),
    ],
  });

  // Place order with native token payment
  const hash = await walletClient.writeContract({
    address: chainConfig.getIntentGatewayAddress("EVM-56"),
    abi: IntentGatewayABI.ABI,
    functionName: "placeOrder",
    args: [
      order,
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    ],
    value: nativeTokenAmount, // Pay fees with BNB
  });

  console.log(`Order placed: ${hash}`);

  // 5. Monitor order status

  while (true) {
    const isFilled = await intentGateway.isOrderFilled(order);
    if (isFilled) {
      console.log("Order filled successfully!");
      break;
    }
    console.log("Waiting for filler...");
    await new Promise((resolve) => setTimeout(resolve, 10000));
  }
}
```

### Example 2: Cancel Expired Order

```typescript
import { EvmChain } from "@hyperbridge/sdk/chain";
import { IntentGateway } from "@hyperbridge/sdk/protocols/intents";
import { IndexerClient } from "@hyperbridge/sdk/client";
import { createQueryClient } from "@hyperbridge/sdk/query-client";
import { ChainConfigService } from "@hyperbridge/sdk/configs/ChainConfigService";
import { parseUnits, createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { bscTestnet } from "viem/chains";
import IntentGatewayABI from "@hyperbridge/sdk/abis/IntentGateway";
import type { Order } from "@hyperbridge/sdk/types";
import { SubstrateChain } from "@hyperbridge/sdk/chain";

async function cancelExpiredOrder(order: Order) {
  // 1. Setup
  const chainConfig = new ChainConfigService();

  const bscChain = new EvmChain({
    chainId: 97,
    host: "0x8Aa0Dea6D675d785A882967Bf38183f6117C09b7",
    rpcUrl: process.env.BSC_CHAPEL,
  });

  const sepoliaChain = new EvmChain({
    chainId: 11155111,
    host: "0x2EdB74C269948b60ec1000040E104cef0eABaae8",
    rpcUrl: process.env.SEPOLIA,
  });

  const intentGateway = new IntentGateway(bscChain, sepoliaChain); // source, dest

  // 2. Setup indexer
  const queryClient = createQueryClient({
    url: process.env.INDEXER_URL,
  });

  const sourceChain = new EvmChain({
    chainId: 97,
    host: "0x8Aa0Dea6D675d785A882967Bf38183f6117C09b7",
    rpcUrl: process.env.BSC_CHAPEL,
  });
  const destChain = new EvmChain({
    chainId: 11155111,
    host: "0x2EdB74C269948b60ec1000040E104cef0eABaae8",
    rpcUrl: process.env.SEPOLIA,
  });
  const hyperbridgeChain = new SubstrateChain({
    wsUrl: process.env.HYPERBRIDGE_GARGANTUA,
    stateMachineId: "KUSAMA-4009",
    consensusStateId: "PAS0",
    hasher: "Keccak",
  });
  await hyperbridgeChain.connect();

  const indexer = new IndexerClient({
    source: sourceChain,
    dest: destChain,
    hyperbridge: hyperbridgeChain,
    queryClient,
    pollInterval: 1_000,
  });

  // 3. Start cancellation
  const cancelGen = intentGateway.cancelOrder(order, indexer);

  let result = await cancelGen.next();

  // 4. Wait for destination finalization
  while (!result.done && result.value?.status !== "DESTINATION_FINALIZED") {
    console.log(`Status: ${result.value?.status}`);
    result = await cancelGen.next();
  }

  const finalizedHeight = result.value.data.proof.height;

  // 5. Get native amount and submit cancel transaction
  const walletClient = createWalletClient({
    account: privateKeyToAccount(process.env.PRIVATE_KEY),
    chain: bscTestnet,
    transport: http(process.env.BSC_CHAPEL),
  });

  const nativeRequired = await intentGateway.quoteCancelNative(order);

  const cancelOptions = {
    relayerFee: 0n,
    height: finalizedHeight,
  };

  const hash = await walletClient.writeContract({
    address: chainConfig.getIntentGatewayAddress("EVM-97"),
    abi: IntentGatewayABI.ABI,
    functionName: "cancelOrder",
    args: [order, cancelOptions],
    value: nativeRequired,
  });

  const publicClient = createPublicClient({
    chain: bscTestnet,
    transport: http(process.env.BSC_CHAPEL),
  });

  // 6. Provide the tx hash back to the generator
  result = await cancelGen.next(hash);

  // 7. Wait for finalization
  while (!result.done) {
    if (result.value?.status === "HYPERBRIDGE_FINALIZED") {
      console.log("Cancellation complete!");
      console.log(`Refund tx: ${result.value.data.metadata.transactionHash}`);
      break;
    }
    result = await cancelGen.next();
  }
}
```

## Calldata Execution on Destination (Advanced)

In advanced flows, you can instruct the destination chain to execute one or more calls atomically once the funds arrive. This enables actions like swapping received tokens, forwarding to another protocol, or composing multiple steps.

How it works:

- Set the order `outputs[0].beneficiary` to the destination chain's Calldispatcher address.
- Provide destination-side call bundle in `order.callData` (ABI-encoded array of calls: `{ to, value, data }[]`).
- The Calldispatcher receives the output tokens and executes the calls with them.

Below is a minimal end-to-end example that performs a USDC swap on the destination chain via Uniswap, using SDK helpers to generate calldata and encoding it for the Intent Gateway:

```typescript
import { EvmChain } from "@hyperbridge/sdk/chain";
import { IntentGateway } from "@hyperbridge/sdk/protocols/intents";
import { ChainConfigService } from "@hyperbridge/sdk/configs/ChainConfigService";
import { bytes20ToBytes32 } from "@hyperbridge/sdk/utils";
import {
  encodeAbiParameters,
  parseUnits,
  createPublicClient,
  http,
  getContract,
} from "viem";
import IntentGatewayABI from "@hyperbridge/sdk/abis/IntentGateway";
import EVM_HOST from "@hyperbridge/sdk/abis/evmHost";

async function placeOrderWithDestinationCalldata() {
  const chainConfig = new ChainConfigService();

  // Source: Ethereum mainnet, Destination: BSC mainnet (example)
  const eth = new EvmChain({
    chainId: 1,
    host: chainConfig.getHostAddress("EVM-1"),
    rpcUrl: process.env.ETH_MAINNET!,
  });
  const bsc = new EvmChain({
    chainId: 56,
    host: chainConfig.getHostAddress("EVM-56"),
    rpcUrl: process.env.BSC_MAINNET!,
  });

  const intentGateway = new IntentGateway(eth, bsc); // source, dest

  // Assets and addresses
  const tokenInSource = chainConfig.getUsdcAsset("EVM-1"); // USDC on Ethereum
  const tokenOutDest = chainConfig.getUsdcAsset("EVM-56"); // USDC on BSC (to Calldispatcher)
  const calldispatcher = chainConfig.getCalldispatcherAddress("EVM-56");

  // Destination action: swap tokenOutDest (USDC) into a target token on BSC via Uniswap V3
  // Use helper to prepare router calldata on destination chain
  const targetTokenOnBsc =
    "0xEa7C32c66413C7F6DDD94c532594BcDF608Fe2c2" as `0x${string}`; // example token
  const amountInSource = parseUnits("5", 6); // 5 usdc on eth
  const amountOutDest = parseUnits("5", 18); // expect 5 usdc on bsc
  const slippageBps = 100n; // 1%, You are expecting to swap 5 usdc to a target token with at most 1% in slippage for the swap

  const { calldata } = await intentGateway.swap.createMultiHopSwapThroughPair(
    intentGateway.dest.client,
    tokenOutDest,
    targetTokenOnBsc,
    amountOutDest,
    "EVM-56",
    calldispatcher,
    "v3",
    slippageBps
  );

  // Encode as tuple[] for Calldispatcher: (to, value, data)[]
  const encodedCalls = encodeAbiParameters(
    [
      {
        type: "tuple[]",
        components: [
          { name: "to", type: "address" },
          { name: "value", type: "uint256" },
          { name: "data", type: "bytes" },
        ],
      },
    ],
    [calldata]
  );

  // Read hex-encoded stateMachine ids
  const ethPublic = createPublicClient({
    transport: http(process.env.ETH_MAINNET!),
  });
  const bscPublic = createPublicClient({
    transport: http(process.env.BSC_MAINNET!),
  });
  const ethHost = getContract({
    address: chainConfig.getHostAddress("EVM-1"),
    abi: EVM_HOST.ABI,
    client: ethPublic,
  });
  const bscHost = getContract({
    address: chainConfig.getHostAddress("EVM-56"),
    abi: EVM_HOST.ABI,
    client: bscPublic,
  });

  // Build order: pay in USDC on source, receive USDC on dest to the Calldispatcher, which executes encodedCalls
  let order = {
    user: bytes20ToBytes32("0xYourAddress"),
    sourceChain: await ethHost.read.host(),
    destChain: await bscHost.read.host(),
    deadline: 65337297000n,
    nonce: 0n,
    fees: 0n,
    outputs: [
      {
        token: bytes20ToBytes32(tokenOutDest),
        amount: amountOutDest,
        beneficiary: bytes20ToBytes32(calldispatcher), // Calldispatcher executes calls
      },
    ],
    inputs: [
      {
        token: bytes20ToBytes32(tokenInSource),
        amount: amountInSource,
      },
    ],
    callData: encodedCalls,
  };

  // Estimate fees (includes buffer, relayer, protocol, and fill gas components)
  const { order: priced, nativeTokenAmount } =
    await intentGateway.estimateFillOrder(order);

  // Approvals omitted for brevity. Then place order paying fees in native token:
  await walletClient.writeContract({
    address: chainConfig.getIntentGatewayAddress("EVM-1"),
    abi: IntentGatewayABI.ABI,
    functionName: "placeOrder",
    args: [priced, "0x"],
    value: nativeTokenAmount,
  });
}
```

Notes and tips:

- Always simulate destination calldata during fee estimation to ensure `fillOrder` succeeds; the SDKâ€™s estimation includes a simulation step and buffers.
- You can compose multiple calls in the `calldata` array; they will be executed in-order in a single atomic context on the destination.

## Further Reading

- [Intent Gateway Smart Contract Documentation](./intent-gateway.mdx)
- [Filler Documentation](./filler)
