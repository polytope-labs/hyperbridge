---
title: Hyperbridge
description: Hyperbridge Protocol Specification
---

# Hyperbridge Protocol

**Secure interoperability** requires the verification of various proofs, including consensus proofs, consensus fault proofs, state proofs, and state transition validity proofs. For blockchains to securely interoperate, they must **verify these proofs onchain** to confirm the finalized (irreversible) state of their counterparty.

However, these verification processes are compute-intensive and do not scale well, particularly when multiple blockchains need to communicate. This limitation leads to the proliferation of _attestation networks_ which employ the use of multi-sig committees who attest to the state of a counterparty chain. These types of architectures have resulted in a cumulative loss of $2 billion in crypto assets. (sources [[1]](https://defillama.com/hacks), [[2]](https://rekt.news/leaderboard/)).

The only true solution to this problem is the coprocessor model, where the verification operations are performed offchain and the results are securely reported back onchain alongside cryptographic proofs of correct execution.

## Coprocessor Model

Hyperbridge is an example of such a coprocessor, more specifically, a [crypto-economic coprocessor](https://blog.polytope.technology/cryptoeconomic-coprocessors). These kinds of coprocessors are blockchains that use their [consensus proofs](https://research.polytope.technology/consensus-proofs) to certify the correctness of the **computations performed onchain**. As a result they are more decentralized, fault-tolerant, censorship resistant, and more importantly, unstoppable.

### Proof Aggregation

Hyperbridge achieves trust-free interoperability by verifying and aggregating the finalized states of **all chains** on its own chain. It then uses a single proof to any chain to prove the finality of the aggregated states. This method allows Hyperbridge to scale trust-free interoperability to all blockchains.

### Permissionless Relayers

Owing to it's use of cryptographic proofs, Hyperbridge is the first cross-chain protocol to host a decentralized and permissionless network of relayers. These relayers, which operate **without the need for any whitelisting or staking**, are tasked with transmitting messages across chains on behalf of users and applications. They are incentivized to relay messages by the fees paid by users who wish to perform cross-chain operations.

This document serves as the canonical specification for the Hyperbridge protocol. It is divided into the following sections:

## Cryptographic Primitives

Hyperbridge is at it's fundamental level a coprocessor for expensive cryptographic operations needed to confirm the correctness of cross-chain messages. This section details all of the cryptographic primitives used in within the various sub-systems in Hyperbridge. These primitives are used to produce and verify the correctness of consensus proofs, consensus fault proofs, state proofs and state transition validity proofs. The primitives are:

- [Hash Functions](/cryptography/hash-functions)
- [Merkle Trees](/cryptography/)
  - [Merkle Mountain Ranges](/state-proofs)
  - [Merkle Patricia Tries](/state-proofs)
- [Abstract Algebra](/state-proofs)
- [Elliptic Curves](/state-proofs)
- [BLS Signatures](/state-proofs)
- [Polynomial Commitment Schemes](/state-proofs)
- [Verkle Tries](/state-proofs)

## Interoperability Proofs

Interoperability proofs are the cryptographic proofs that attest to the validity of cross-chain messages. These consists of **consensus proofs** which convinces a blockchain of the finalized chain of it's counterparty. **State proofs** which attest to some portions of the **finalized state** of a counterparty chain. Combined, these proofs can be used to mediate secure communication between blockchains.

- [Consensus Proofs](/consensus-proofs)
- [State Machine Proofs](/consensus-proofs)

## Interoperable State Machine Protocol

The Interoperable State Machine Protocol (ISMP) is a simplified protocol for cross-chain interoperability. The goal of ISMP is to provide secure cross-chain messaging and state reads. The protocol is designed to be simple and easy to implement, while still providing the necessary security guarantees.

- [Host Interface](/consensus-proofs)
- [Consensus Client](/consensus-proofs)
- [State Machine Client](/state-proofs)
- [Router](/state-proofs)
- [Dispatcher](/state-proofs)
- [Requests](/state-proofs)
- [Responses](/state-proofs)
- [Timeouts](/state-proofs)
- [Proxies](/state-proofs)

## Consensus Algorithms

These are the algorithms that are used to verify the consensus mechanism for a given chain. Different chains can have different consensus mechanisms, and so different algorithms are needed to verify the correctness of each mechanism. The consensus verification algorithms implemented in Hyperbridge are:

- [BEEFY (Polkadot)](/consensus-proofs)
- [Sync Committee (Ethereum)](/consensus-proofs)
- [Casper FFG (Ethereum)](/state-proofs)
- [Parlia (Bsc)](/state-proofs)

## State Machine Algorithms

These are the algorithms that are used to verify the state commitments for a given state machine. In this context, these are the state commitments posted to it's consensus layer. Where the hyperbridge protocol must leverage the state trie scheme for it's consensus layer to verify the finalized state of a state machine. The state machine verification algorithms implemented in Hyperbridge are:

- [Parachain](/state-proofs)
- [Fault Dispute Games (Op Stack)](/state-proofs)
- [L2 Oracle (Op Stack)](/state-proofs)
- [Orbit (Arbitrum)](/state-proofs)

## Runtime Modules

These are the runtime modules that are included in the Hyperbridge blockchain. These modules are responsible for implementing the various components of the protocol, such as the consensus and state machine verifiers, cross-chain governance, relayer incentivization, and other components. The runtime modules included in Hyperbridge are:

- [ISMP](/consensus-proofs)
- [ISMP Parachain](/consensus-proofs)
- [ISMP Sync Committee](/state-proofs)
- [Fishermen](/state-proofs)
- [Host Executive](/state-proofs)
- [Relayer](/state-proofs)
